import fs from 'fs/promises';

import { JobCardConfig } from './jobcard/config';
import { CreditService } from './jobcard/credit.service';
import { SequenceResolver } from './jobcard/sequenceResolver.service';
import { TemplateProcessor } from './jobcard/templateProcessor.service';
import { FileManager } from './jobcard/fileManager.service';

import { prisma } from '@prodgenie/libs/prisma';
import { FileHelperService } from '@prodgenie/libs/server-services';

export class JobCardService {
  private creditService = new CreditService();
  private resolver = new SequenceResolver();
  private processor = new TemplateProcessor();
  private files = new FileManager();
  private helper = new FileHelperService();

  async generateJobCard({
    bom,
    jobCardForm,
    user,
    titleBlock,
    signedUrl,
    printingDetails,
    activeWorkspace,
  }) {
    if (!bom.length) return console.warn('bom is empty');
    const workspaceId = activeWorkspace?.workspace?.id;
    await this.creditService.ensure(workspaceId);

    const contextBase = {
      ...jobCardForm.global,
      user,
      titleBlock,
      printingDetails,
      keyword: { currentDate: new Date().toISOString().split('T')[0] },
    };

    const drawing = await this.helper.downloadToTemp(signedUrl, 'drawing.pdf');
    const templates: string[] = [];

    for (const bomItem of bom) {
      const product = await this.resolver.resolve(bomItem.description);
      if (!product?.path) continue;

      const sequence = await this.helper.fetchJsonFromSignedUrl(product.path);
      for (const section of sequence.sections) {
        const templateData = await prisma.file.findFirst({
          where: {
            type: JobCardConfig.fileTypes.template,
            name: `${section.name}${JobCardConfig.extensions.template}`,
          },
          select: { data: true },
        });
        if (!templateData) continue;
        const populated = await this.processor.populate(
          section.path,
          templateData.data,
          { ...contextBase, bomItem, sequenceData: product.data }
        );
        templates.push(populated);
      }
      templates.push(this.processor.pageBreak());
    }

    const finalDoc = await this.processor.combine(templates);
    const pdfPath = await this.files.saveAsPDF(
      finalDoc,
      jobCardForm.global.jobCardNumber
    );
    const jobCardUrl = await this.files.uploadJobCard(
      pdfPath,
      user,
      activeWorkspace
    );
    await this.creditService.deduct(workspaceId);

    await fs.rm('./tmp', { recursive: true });
    return jobCardUrl;
  }

  async getJobCardNumber(workspace: {
    workspace: { id: string; name: string };
  }) {
    const latest = await prisma.file.findFirst({
      where: { workspaceId: workspace.workspace.id, type: 'jobCard' },
      orderBy: { name: 'desc' },
      select: { name: true },
    });

    const prefix = `${workspace.workspace.name.slice(0, 3).toUpperCase()}-JC-`;
    const lastNumber = parseInt(
      latest?.name?.split('.')[0].split('-')[2] || '0',
      10
    );
    const nextNumber = (lastNumber + 1).toString().padStart(4, '0');

    return { data: `${prefix}${nextNumber}` };
  }
}
